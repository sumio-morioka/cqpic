
　以下のファイルを収録しました．

▲マイクロチップテクノロジー社のＰＩＣ16Ｆ84相当のワンチップ・マイコン．Ｃ
ＱＰＩＣの，論理合成可能なＲＴＬソース(ＶＨＤＬファイル)．
　使用デバイスやＣＡＤにほとんど依存しないコードです．

▲ＰＩＣのアセンブラＭＰＡＳＭが出力するＨＥＸファイルを論理合成可能なＶＨ
ＤＬ(ＣＱＰＩＣのプログラムＲＯＭ部に相当)や，ＡＬＴＥＲＡ社ＭＩＦファイル
へ変換するプログラムのＣソースとＷindows用バイナリ．
　アセンブラの入手についてはhttp://www.microchip.comを参照してください．

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
よくある質問・トラブル
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
① デバイスにフィットできない

　まず，使用するデバイスに十分なＲＡＭ・ＲＯＭの容量があるかチェックしてくだ
さい．アーカイブのソースでは，ＲＡＭは128バイト，ＲＯＭは14bit*8192ワード
（ＰＩＣ16Ｆ84と同じ）に設定されています．ＲＯＭは実行したいプログラムぶんの
容量があればよいので，必要最低限まで削減してください（progrom.vhd中の容量設定
やバス幅を変更してください）．逆に，メモリが十分あるなら，ＲＡＭを増やすことも
できます．

　メモリではなくロジックセルが足りない場合，命令を削るなどしてコアのサイズを
削るしかありません．できればより大きなデバイスを使ってください．

② メモリにＬＰＭが使えない（おもにXilinx社のデバイスなど）

　Xilinx社のデバイスを使う場合，dataram.vhdやprogrom.vhdをコアジェネレータなど
で作成したメモリと差し替えてください．この際，レイテンシは１クロックないし０ク
ロックにしてください．２クロック以上では動きません．もし可能なら，入力側を
registeredにしてください．入力側にレジスタを置くのが不可なら，レジスタなしか，
出力側に置くので構いませんが，その場合は次の③の可能性も一応頭に入れておいてください．

　ASICでは，使うデバイスに準備されているメモリないしレジスタファイルを使用して
ください．タイミングは上記のとおりにしてください．なお，CQPICはmclkの立ち上がり
に同期してアドレス，データ，ライトストローブなどを出してきます．データの読み込み
もmclkの立ち上がりに同期して行います．

③ ＲＡＭに正しい値を書き込めないようだ．．．？

　まず確実に起こらないと思いますが，FPGA内部のレイアウト・配線遅延の状況によって
は，ＲＡＭに正しい値が書けないという現象が発生するかもしれません．その場合，以下
の順に手を打ってみてください：
(1) 入力側にレジスタを持つＲＡＭを使用する（出力側をregisteredにしない）．
(2) piccore.vhdから出てくるwriteramとclkinのANDを取り，それをＲＡＭのライト信号とする．
(3) piccore.vhdから出てくるramadr(8 downto 0)にディレイラインを入れる．

④ コンパイル時にエラーやワーニングが出る

　MAX+PLUSの一部のバージョンでは，二重代入をしているというような警告が出ることが
あります．これはソースではなく処理系の問題なので無視してください．LeonardoSpectrum
やFPGA Expressなどの代表的FPGA用合成ツール，その他ASIC用の処理系などでは問題なく合
成できるはずですが，もし問題が解決しないようならご一報いただければ幸いです．

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
ＣＱＰＩＣとＰＩＣ16Ｆ84の相違
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
　いくつか違いはあるものの，ＣＱＰＩＣはＰＩＣ16Ｆ84のほぼフルセットを
実現しています．全35種類命令をサポートするのはもちろん，割り込みやスリー
プ，ＷＤＴ(ウオッチ・ドッグ・タイマ)やＴＭＲ0などもあります．違いのある
点についても，ＰＩＣ16Ｆ84より使い勝手をよくすることが目的になっています．
　トランジスタ技術誌1999年12月号の記載と異なり，ＥＥＰＲＯＭエリア用のバス
やレジスタ，ＥＥライト割り込みも一応用意してあり，また，ＲＡＭは(実装すれば)
バンク0～バンク3のすべてを使えるようになっています．\pic\fullset中のソース
ではバンク0だけ実装してありますが，dataram.vhdを見ればすぐ分かるとおり，
メモリの実装量を変更するのは簡単にできます．

　そのほか，ＰＩＣ16Ｆ84との相違をまとめます．

▲ＩＯＲＬＷとＩＯＲＷＦ命令について，Ｚフラグの変更の仕方をＰＩＣ16Ｆ84デ
ータシートに合わせ，演算結果が0でないとき立つようにしてあります．ただしpic
core.vhdの815行目近辺に

-- SELECT ONE OF THE FOLLOWING TWO SENTENCES
					-- IORLW or IORWF instructions:
	status_reg(2)	<＝ not aluout_zero_node;
--	status_reg(2)	<＝ aluout_zero_node;

と記述された箇所がありますが，このコメント・アウトする行を変更して

-- SELECT ONE OF THE FOLLOWING TWO SENTENCES
					-- IORLW or IORWF instructions:
--	status_reg(2)	<＝ not aluout_zero_node;
	status_reg(2)	<＝ aluout_zero_node;

とすれば，ほかの命令と同じく，結果が0のときフラグが立つようにできます．

▲ＰＯＲＴＡ,Ｂは双方向端子ではなく，入力端子と出力端子を分けてあります．
ＴＲＩＳレジスタは実装してありますが，動作に影響しません．また，割り込み入
力もＰＯＲＴＢとは独立した端子にしてあります．このような分離によって，モジ
ュールの使い勝手がかなりよくなっているはずです．
　ただし双方向端子にするのも簡単で，階層トップ(cqpic.vhd)で端子をinoutとし
て宣言し，トライ・ステートバス経由で出力するようにします．具体的な例は，Ｖ
ＨＤＬの解説本や，本誌1999年10月号の本連載などを見てください．

▲ ＷＤＴ使用時は，ＷＤＴ用クロックを外から供給する必要があります．クロッ
ク周波数は外部で調整すればよいので，ＷＤＴでプリスケーラは使えなくなってい
ます．
　ＰＩＣ16Ｆ84と異なり，ＴＭＲ0でプリスケーラを使っても，ＷＤＴタイム・ア
ップが厳しくなるようなことはないので，ずっとＣＰＵの使い勝手がよくなります．

▲スリープ中でもＣＰＵ内部でクロックが止まりません．スリープ信号powerdow
nを外部へ出してあるので，それがＨになったら外部でクロック供給を止めます．
スリープ解除信号startclkinも出してあるので，それがＨになったらクロック供給
を再開してください．クロック停止を行うときは，ハザードがのらないようによく
注意した上で，クロック入力clkinをＨに保つようにしてください．

▲ＥＥＰＲＯＭについては，ＲＯＭやＲＡＭとは独立したデータ・バス，アドレス
バスを出してあります．ただし，ＥＥＰＲＯＭのリード/ライト制御シーケンサな
どは内蔵しておらず，ＣＱＰＩＣはリード/ライト要求を出す(ハンドシェイクをす
る)だけですので，必要に応じてシーケンサを外付けしてＥＥＰＲＯＭの消去や書
き込みを行ってください．なお，ＥＥＰＲＯＭでなく，ＲＯＭやＲＡＭを接続する
ことも可能です．

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
実行するＰＩＣプログラムの変更の仕方
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
　ＣＰＵで実行するプログラムの変更は，次の手順で行います．
(1) プログラムを作ってＭＰＡＳＭなどでアセンブルし，ＨＥＸファイルを作りま
す．生成するＨＥＸファイルの指定は，Ｄefaultにしておいてください．
　なお，プログラム名はprogrom.asmにしてください．このとき，ＨＥＸファイル
はprogrom.hexができます．
(2) hex2vhd.exeで，そのＨＥＸファイルからＶＨＤＬファイルを作ります．ＨＥ
Ｘファイルのアイコンをhex2vhd.exeへdrag&dropすると作れます．そのとき，プロ
グラムがＲＯＭのバス幅を聞いてきますが，通常は「0」と入力してください(デフ
ォルトの13ビットになります)．もしＣＱＰＩＣを改造してＲＯＭのバス幅を変更
した場合は，そのバス幅を入力してください．
(2') もしＡＬＴＥＲＡ用のＲＯＭファイルを使っているなら，ＶＨＤＬではなく
ＭＩＦファイルを作ります．hex2mif.exeを使ってください．
(3) 生成されたＶＨＤＬファイルはprogrom.vhdとなるはずです(ＭＩＦファイルな
らprogrom.mif)．もとのprogrom.vhdまたはprogrom.mifを新しいファイルと交換し
てください．
(4) cqpic.vhdを階層トップに，再度論理合成を行います．ただし，デモ版のプロ
グラムを変更した場合は，pictest.gdfを階層トップにしてください．

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
ＣＰＵコアのユーザインターフェース
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
　ＣＰＵコアpiccore.vhdのインターフェースは以下のとおりです．cqpic.vhdが，
実際のつなぎかたの参考になるでしょう．

	generic (
		ＳＴＡＣＫ_ＳＩＺＥ	: integer :＝ 8;  スタックサイズ．自由に変えてください
		ＷＤＴ_ＳＩＺＥ	: integer :＝ 255     ＷＤＴの最大値．自由に変えてください
	);
	port (
	-- program ＲＯＭ data bus/address bus
		progdata	: in  std_logic_vector(13 downto 0); ＲＯＭのデータ・バス
		progadr		: out std_logic_vector(12 downto 0); ＲＯＭのアドレスバス
											ＲＯＭの/ＯＥや/ＲＤはＬ固定(常に出力)です．

	-- data ＲＡＭ data bus/address bus/control signals
注意：data RAMは出力レジスタ付きのものにしてください（DATARAM.VHDを参照）
		ramdtin		: in  std_logic_vector(7 downto 0);  ＲＡＭのデータ・バス(ＲＡＭ->ＣＰＵ)
		ramdtout	: out std_logic_vector(7 downto 0);  ＲＡＭのデータ・バス(ＣＰＵ->ＲＡＭ)
		ramadr		: out std_logic_vector(8 downto 0);　ＲＡＭのアドレスバス
		readram		: out std_logic;					 ＲＡＭのリードイネーブル(Ｈアクティブ)
		writeram	: out std_logic;					 ＲＡＭのライトイネーブル(Ｈアクティブ)

	-- ＥＥＰＲＯＭ data bus/address bus
		existeeprom	: in  std_logic;					ＥＥＰＲＯＭがなければＬ，あればＨ
		eepdtin		: in  std_logic_vector(7 downto 0);	ＥＥＰＲＯＭのデータ・バス(ＥＥＰＲＯＭ->ＣＰＵ)
		eepdtout	: out std_logic_vector(7 downto 0);	ＥＥＰＲＯＭのデータ・バス(ＣＰＵ->ＥＥＰＲＯＭ)
		eepadr		: out std_logic_vector(7 downto 0);	ＥＥＰＲＯＭのアドレスバス
		readeepreq	: out std_logic;					ＥＥＰＲＯＭのリード要求(ハンドシェイク)
		readeepack	: in  std_logic;					ＥＥＰＲＯＭのリード完了通知を入れる．ＥＥＰＲＯＭがなければＨ固定
		writeeepreq	: out std_logic;					ＥＥＰＲＯＭのライト要求(ハンドシェイク)
		writeeepack	: in  std_logic;					ＥＥＰＲＯＭのライト完了通知を要れる．ＥＥＰＲＯＭがなければＨ固定

	-- Ｉ/Ｏ ports
		porta_in	: in  std_logic_vector(4 downto 0);	ポートＡ入力
		porta_out	: out std_logic_vector(4 downto 0);	ポートＡ出力
		porta_dir	: out std_logic_vector(4 downto 0);	ポートＡ信号方向(ＴＲＩＳＡ)．Ｈなら入力

		portb_in	: in  std_logic_vector(7 downto 0);	ポートＢ入力
		portb_out	: out std_logic_vector(7 downto 0);	ポートＢ出力
		portb_dir	: out std_logic_vector(7 downto 0);	ポートＢ信号方向(ＴＲＩＳＢ)．Ｈなら入力

		rbpu		: out std_logic;                   ＲＢＰＵ(端子プルアップ)信号．通常使いません．

	-- ＰＯＲＴ-Ｂ interrupt input
		int0		: in  std_logic;					ＲＢ0割り込み入力
		int4		: in  std_logic;					ＲＢ4割り込み入力
		int5		: in  std_logic;					ＲＢ5割り込み入力
		int6		: in  std_logic;					ＲＢ6割り込み入力
		int7		: in  std_logic;					ＲＢ7割り込み入力

	-- ＴＭＲ0 Ｃontrol
		t0cki		: in  std_logic;					ＴＭＲ0外部クロック入力(もとはＲＡ4)

	-- Ｗatch Ｄog Ｔimer Ｃontrol
		wdtena		: in  std_logic;					ＷＤＴのイネーブル．ＷＤＴを使うならＨ
		wdtclk		: in  std_logic;					ＷＤＴの動作クロック．
		wdtfull		: out std_logic;					ＣＰＵがＷＤＴリセットを実行中Ｈになる

	-- ＣＰＵ clock stop/start indicators
		powerdown	: out std_logic;					ＣＰＵがＳＬＥＥＰ中Ｈになる．クロックclkinを停止できます．
		startclkin	: out std_logic;					ＳＬＥＥＰ解除信号．Ｈになったらクロックを供給してください．

	-- ＣＰＵ reset
		ponrst_n	: in  std_logic;					パワーＯＮリセット(Ｌアクティブ)．パワーＯＮ時，clkin供給が安定するまでかならずＬに保ってください．ＣＰＵ内部は完全にリセットされる．
		mclr_n		: in  std_logic;					リセット信号(Ｌアクティブ)．パワーＯＮ後のリセットに使います．ＣＰＵの内部レジスタ値が一部残るのが，ponrst_nとの違い．

	-- ＣＰＵ clock
		clkin		: in  std_logic;					ＣＰＵクロック入力．
		clkout		: out std_logic						clkin/4が出力されます．ＳＬＥＥＰ中は停止します．
	);

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
ＶＨＤＬの記述スタイルについて
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
　ソースコードは抽象度の高い書き方をしてあるので，機能変更は難しくありませ
ん．ゲート・レベルで全回路を作成していると機能変更はとてもたいへんなので，
気軽に変更ができるというのは，ＨＤＬで機能記述をする大きなメリットです．
　ただし，内部処理の流れを理解しないことには，やはり変更は無理でしょう．内
部処理の流れは，本書記事と，piccore.vhd中のコメントを参照してください．理
解のこつとしては，
▲ソースを始めから一行ずつ理解しようとするのではなくて，おおまかな流れをコ
メントからまずつかむ．ネストの浅い位置にあるコメントが全体的な処理，深い位
置にあるコメントが細かい処理を説明しています．
▲プログラム的な感覚でprocessやif,case文をシーケンシャル実行と思って眺める
のではなく，「どのようなレジスタが存在しているか」をまず把握し，その次に
「いつ，どのような条件のとき，各レジスタにどのような値が代入されるか」を捉
える．
などが挙げられます．

